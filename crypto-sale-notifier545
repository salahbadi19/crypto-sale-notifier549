#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø£ÙˆØ±Ø¯Ø± Ø¨ÙˆÙƒ Ù„Ù€ 10 Ø¹Ù…Ù„Ø§Øª Ù‚ÙˆÙŠØ© Ø¹Ù„Ù‰ Ø¨ÙŠÙ†Ø§Ù†Ø³ (Spot) Ù…Ø¹ Ø­Ø³Ø§Ø¨ Ù‚ÙˆØ© Ø§Ù„Ø´Ø±Ø§Ø¡/Ø§Ù„Ø¨ÙŠØ¹
Ø¯Ø§Ø®Ù„ Ù†Ø§ÙØ°Ø© Ù†Ø³Ø¨Ø© Ù…Ø¦ÙˆÙŠØ© Ø­ÙˆÙ„ Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠØŒ ÙˆØ¹Ø±Ø¶ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ ÙÙŠ Ø¬Ø¯ÙˆÙ„ Ø­ÙŠ Ù…Ù„ÙˆÙ‘Ù†.

Ø§Ù„Ù…Ø²Ø§ÙŠØ§:
- ÙŠØ¬Ù„Ø¨ Ø¹Ù…Ù‚ Ø§Ù„Ø³ÙˆÙ‚ (order book depth) Ø­ØªÙ‰ 500 Ù…Ø³ØªÙˆÙ‰ Ù„ÙƒÙ„ Ø±Ù…Ø².
- ÙŠØ­Ø³Ø¨ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø£Ø­Ø¬Ø§Ù… Ø§Ù„Ø¹Ø±ÙˆØ¶ (asks) ÙˆØ§Ù„Ø·Ù„Ø¨Ø§Øª (bids) Ø¯Ø§Ø®Ù„ Ù†Ø§ÙØ°Ø© +/- Ù†Ø³Ø¨Ø© Ù…Ø¦ÙˆÙŠØ© Ù…Ù† Ø³Ø¹Ø± Ø§Ù„Ù…Ù†ØªØµÙ.
- ÙŠØ®Ø±Ø¬ Ù†Ø³Ø¨Ø© Buy% Ùˆ Sell% Ùˆ Imbalance Ùˆ Spread Ø¨Ø§Ù„Ù€ bps.
- Ø¬Ø¯ÙˆÙ„ Ø­ÙŠ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…ÙƒØªØ¨Ø© Rich Ù…Ø¹ Ø£Ù„ÙˆØ§Ù† Ø¬Ù…ÙŠÙ„Ø©.
- ÙŠØ·Ù„Ø¨ API Key Ùˆ Secret ÙÙŠ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© (Ø§Ø®ØªÙŠØ§Ø±ÙŠØŒ Ù„Ø£Ù† Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¹Ù…Ù‚ Ø¹Ø§Ù…Ø©ØŒ Ù„ÙƒÙ†Ù‡ Ø¬Ø§Ù‡Ø² Ù„Ù„ØªÙˆØ³Ù‘Ø¹ Ù„Ø§Ø­Ù‚Ù‹Ø§).

Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„ØªØ´ØºÙŠÙ„:
1) Ø«Ø¨Ù‘Øª Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª:
   pip install aiohttp rich

2) Ø´ØºÙ‘Ù„ Ø§Ù„Ø³ÙƒØ±Ø¨Øª:
   python orderflow_monitor.py

3) Ø¹Ù†Ø¯ Ø§Ù„ØªØ´ØºÙŠÙ„ Ø³ÙŠØ·Ù„Ø¨:
   - Binance API Key
   - Binance API Secret
   - Ù†Ø³Ø¨Ø© Ø§Ù„Ù†Ø§ÙØ°Ø© Ø­ÙˆÙ„ Ø§Ù„Ø³Ø¹Ø± (Ù…Ø«Ù„Ø§Ù‹ 0.5 ÙŠØ¹Ù†ÙŠ Â±0.5%)
   - ÙØªØ±Ø© Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø¨Ø§Ù„Ø«ÙˆØ§Ù†ÙŠ (Ø§ÙØªØ±Ø§Ø¶ÙŠ 3 Ø«ÙˆØ§Ù†)

Ù…Ù„Ø§Ø­Ø¸Ø©: Ù‡Ø°Ø§ Ø§Ù„Ø³ÙƒØ±Ø¨Øª ÙŠØ³ØªØ®Ø¯Ù… ÙˆØ§Ø¬Ù‡Ø© REST Ø§Ù„Ø¹Ø§Ù…Ø© Ù„Ø¨ÙŠÙ†Ø§Ù†Ø³ Ø¨Ø¯ÙˆÙ† ØªÙˆÙ‚ÙŠØ¹ØŒ
ÙˆÙ„Ø§ ÙŠØ±Ø³Ù„ Ù…ÙØ§ØªÙŠØ­Ùƒ Ø¥Ù„Ø§ Ø¥Ø°Ø§ Ø£Ø¶ÙØª Ù„Ø§Ø­Ù‚Ù‹Ø§ Ù†Ù‡Ø§ÙŠØ§Øª Ø®Ø§ØµØ© Ø¨Ø§Ù„Ø­Ø³Ø§Ø¨.
"""

import asyncio
import math
import time
from dataclasses import dataclass
from typing import Dict, List, Tuple

import aiohttp
from rich.live import Live
from rich.table import Table
from rich.console import Console
from rich import box

BINANCE_BASE = "https://api.binance.com"

# Ø§Ù„Ø±Ù…ÙˆØ² Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©: Ø¹Ø¯Ù‘Ù„ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© ÙƒÙ…Ø§ ØªØ­Ø¨
DEFAULT_SYMBOLS = [
    "BTCUSDT",
    "ETHUSDT",
    "BNBUSDT",
    "SOLUSDT",
    "DOGEUSDT",
    "XRPUSDT",
    "ADAUSDT",
    "TONUSDT",
    "TRXUSDT",
    "DOTUSDT",
]

console = Console()

@dataclass
class PairStats:
    symbol: str
    mid_price: float
    spread_bps: float
    bids_vol: float
    asks_vol: float
    buy_pct: float
    sell_pct: float
    imbalance: float  # (bids-asks)/(bids+asks)
    last_update: float


def human(n: float) -> str:
    """ØªÙ†Ø³ÙŠÙ‚ Ù…Ø®ØªØµØ± Ù„Ù„Ø£Ø±Ù‚Ø§Ù… Ø§Ù„ÙƒØ¨ÙŠØ±Ø©."""
    if math.isnan(n) or math.isinf(n):
        return "-"
    absn = abs(n)
    if absn >= 1_000_000_000:
        return f"{n/1_000_000_000:.2f}B"
    if absn >= 1_000_000:
        return f"{n/1_000_000:.2f}M"
    if absn >= 1_000:
        return f"{n/1_000:.2f}K"
    return f"{n:.2f}"


async def fetch_depth(session: aiohttp.ClientSession, symbol: str, limit: int = 500) -> Dict:
    url = f"{BINANCE_BASE}/api/v3/depth"
    params = {"symbol": symbol, "limit": str(limit)}
    async with session.get(url, params=params, timeout=10) as r:
        r.raise_for_status()
        return await r.json()


def calc_stats(symbol: str, depth: Dict, pct_window: float) -> PairStats:
    bids = depth.get("bids", [])
    asks = depth.get("asks", [])
    if not bids or not asks:
        return PairStats(symbol, float("nan"), float("nan"), 0.0, 0.0, 0.0, 0.0, 0.0, time.time())

    best_bid = float(bids[0][0])
    best_ask = float(asks[0][0])
    mid = (best_bid + best_ask) / 2.0
    spread_bps = ((best_ask - best_bid) / mid) * 10_000  # basis points

    lower = mid * (1 - pct_window / 100.0)
    upper = mid * (1 + pct_window / 100.0)

    bids_vol = 0.0
    for p, q in bids:
        price = float(p)
        qty = float(q)
        if price >= lower:
            bids_vol += qty
        else:
            break  # Ø¨Ù‚ÙŠØ© Ø§Ù„Ø¹Ø±ÙˆØ¶ Ø£Ø¨Ø¹Ø¯ Ù…Ù† Ø§Ù„Ù†Ø§ÙØ°Ø©

    asks_vol = 0.0
    for p, q in asks:
        price = float(p)
        qty = float(q)
        if price <= upper:
            asks_vol += qty
        else:
            break

    total = bids_vol + asks_vol
    if total <= 0:
        buy_pct = sell_pct = 0.0
        imbalance = 0.0
    else:
        buy_pct = (bids_vol / total) * 100.0
        sell_pct = (asks_vol / total) * 100.0
        imbalance = (bids_vol - asks_vol) / total

    return PairStats(
        symbol=symbol,
        mid_price=mid,
        spread_bps=spread_bps,
        bids_vol=bids_vol,
        asks_vol=asks_vol,
        buy_pct=buy_pct,
        sell_pct=sell_pct,
        imbalance=imbalance,
        last_update=time.time(),
    )


def build_table(stats_list: List[PairStats], pct_window: float) -> Table:
    table = Table(
        title=f"ğŸ“Š Binance Order Book Monitor  Â±{pct_window:.2f}% Window",
        box=box.ROUNDED,
        expand=True,
        show_lines=False,
        title_style="bold cyan",
    )
    table.add_column("#", justify="right", style="bold dim")
    table.add_column("Symbol", style="bold white")
    table.add_column("Price", justify="right")
    table.add_column("Spread (bps)", justify="right")
    table.add_column("Bids Vol", justify="right", style="green")
    table.add_column("Asks Vol", justify="right", style="red")
    table.add_column("Buy%", justify="right", style="bold green")
    table.add_column("Sell%", justify="right", style="bold red")
    table.add_column("Imbalance", justify="right")
    table.add_column("Updated", justify="right", style="dim")

    # ØªØ±ØªÙŠØ¨ Ø­Ø³Ø¨ Ø£Ø¹Ù„Ù‰ Imbalance Ù„ØµØ§Ù„Ø­ Ø§Ù„Ø´Ø±Ø§Ø¡
    stats_sorted = sorted(stats_list, key=lambda s: s.imbalance, reverse=True)

    now = time.time()
    for i, s in enumerate(stats_sorted, 1):
        age = now - s.last_update
        age_s = f"{age:.1f}s"

        imb_color = "green" if s.imbalance > 0 else ("red" if s.imbalance < 0 else "yellow")
        imb_txt = f"[bold {imb_color}]{s.imbalance:+.2%}[/]"

        table.add_row(
            str(i),
            s.symbol,
            human(s.mid_price),
            f"{s.spread_bps:.1f}",
            human(s.bids_vol),
            human(s.asks_vol),
            f"{s.buy_pct:5.1f}%",
            f"{s.sell_pct:5.1f}%",
            imb_txt,
            age_s,
        )
    return table


async def gather_stats(session: aiohttp.ClientSession, symbols: List[str], pct_window: float) -> List[PairStats]:
    tasks = [fetch_depth(session, sym) for sym in symbols]
    depths = await asyncio.gather(*tasks, return_exceptions=True)
    stats: List[PairStats] = []
    for sym, d in zip(symbols, depths):
        if isinstance(d, Exception):
            console.print(f"[red]ÙØ´Ù„ Ø¬Ù„Ø¨ {sym}: {d}")
            continue
        try:
            s = calc_stats(sym, d, pct_window)
            stats.append(s)
        except Exception as e:
            console.print(f"[red]Ø®Ø·Ø£ Ø­Ø³Ø§Ø¨ {sym}: {e}")
    return stats


async def main():
    console.print("[bold cyan]Binance Order Book Monitor[/]")
    api_key = input("Enter Binance API Key (Ø§Ø®ØªÙŠØ§Ø±ÙŠ): ")
    # Ù…Ø¨Ø¯Ø¦ÙŠÙ‹Ø§ ØºÙŠØ± Ù…Ø³ØªØ®Ø¯Ù… Ù„Ø£Ù†Ù†Ø§ Ù†Ø³ØªØ®Ø¯Ù… Ù†Ù‡Ø§ÙŠØ§Øª Ø¹Ø§Ù…Ø©
    from getpass import getpass
    _ = getpass("Enter Binance API Secret (Ø§Ø®ØªÙŠØ§Ø±ÙŠ): ")

    pct_str = input("Ø£Ø¯Ø®Ù„ Ù†Ø³Ø¨Ø© Ø§Ù„Ù†Ø§ÙØ°Ø© Ø­ÙˆÙ„ Ø§Ù„Ø³Ø¹Ø± % (Ù…Ø«Ø§Ù„ 0.5): ") or "0.5"
    try:
        pct_window = float(pct_str)
    except ValueError:
        pct_window = 0.5

    interval_str = input("ÙØªØ±Ø© Ø§Ù„ØªØ­Ø¯ÙŠØ« Ø¨Ø§Ù„Ø«ÙˆØ§Ù†ÙŠ (Ø§ÙØªØ±Ø§Ø¶ÙŠ 3): ") or "3"
    try:
        refresh_sec = max(1, int(float(interval_str)))
    except ValueError:
        refresh_sec = 3

    symbols_input = input(
        "Ø£Ø¯Ø®Ù„ Ø§Ù„Ø±Ù…ÙˆØ² Ù…ÙØµÙˆÙ„Ø© Ø¨ÙÙˆØ§ØµÙ„ (Enter Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ 10): "
    ).strip()
    symbols = (
        [s.strip().upper() for s in symbols_input.split(",") if s.strip()]
        if symbols_input
        else DEFAULT_SYMBOLS
    )

    headers = {"X-MBX-APIKEY": api_key} if api_key else {}

    timeout = aiohttp.ClientTimeout(total=15)
    async with aiohttp.ClientSession(headers=headers, timeout=timeout) as session:
        with Live(console=console, auto_refresh=False, screen=False) as live:
            while True:
                try:
                    stats = await gather_stats(session, symbols, pct_window)
                    table = build_table(stats, pct_window)
                    live.update(table, refresh=True)
                except Exception as e:
                    console.print(f"[red]Ø­Ø¯Ø« Ø®Ø·Ø£ Ø¹Ø§Ù…: {e}")
                await asyncio.sleep(refresh_sec)


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nØ®Ø±ÙˆØ¬â€¦")
